You're about to implement a world-class URL parsing system. This is critical infrastructure for our GEO optimization analysis tool.

## THE MISSION
Transform ANY user input into a clean, normalized domain for analysis. Users might paste URLs from anywhere - their browser bar, marketing materials, or type from memory. We need bulletproof domain extraction.

## IMPLEMENTATION REQUIREMENTS

### 1. URL NORMALIZATION FUNCTION
Create a robust URL parser that handles ALL these cases:
```javascript
// utils/urlParser.js or lib/urlNormalizer.ts

export const extractCleanDomain = (userInput) => {
  // Remove whitespace
  let url = userInput.trim();
  
  // Handle protocol - add if missing
  if (!url.match(/^https?:\/\//i)) {
    url = 'https://' + url;
  }
  
  try {
    const urlObject = new URL(url);
    
    // Extract just the hostname (domain + TLD)
    let domain = urlObject.hostname;
    
    // Remove 'www.' prefix if present
    domain = domain.replace(/^www\./i, '');
    
    // Return clean domain
    return domain.toLowerCase();
    
  } catch (error) {
    // Fallback regex for malformed URLs
    const domainMatch = url.match(/(?:https?:\/\/)?(?:www\.)?([^\/\s]+\.[a-z]{2,})/i);
    if (domainMatch) {
      return domainMatch[1].toLowerCase();
    }
    
    // Last resort - try to extract anything that looks like a domain
    const basicMatch = userInput.match(/([a-zA-Z0-9-]+\.[a-z]{2,})/i);
    if (basicMatch) {
      return basicMatch[1].toLowerCase();
    }
    
    throw new Error('Invalid URL format');
  }
};
```

### 2. INTEGRATE WITH SEARCH COMPONENT

Update your search/analysis component:
```javascript
const handleAnalysis = async (userInput) => {
  try {
    // Extract clean domain
    const cleanDomain = extractCleanDomain(userInput);
    
    // Visual feedback - show user what we're analyzing
    setProcessedUrl(cleanDomain);
    showToast(`Analyzing ${cleanDomain}...`, 'info');
    
    // Show loading state
    setIsAnalyzing(true);
    
    // Call your existing analysis with CLEAN domain
    const results = await analyzeWebsite(cleanDomain);
    
    // Success flow
    router.push(`/analysis?domain=${encodeURIComponent(cleanDomain)}`);
    
  } catch (error) {
    if (error.message === 'Invalid URL format') {
      showError("Please enter a valid website URL (e.g., example.com)");
    } else {
      showError("Analysis failed. Please try again.");
    }
  } finally {
    setIsAnalyzing(false);
  }
};
```

### 3. TEST CASES TO HANDLE

Your function MUST correctly parse ALL of these inputs into clean domains:
```javascript
const testCases = [
  // User inputs â†’ Expected output
  'example.com' â†’ 'example.com',
  'www.example.com' â†’ 'example.com',
  'https://example.com' â†’ 'example.com',
  'http://www.example.com' â†’ 'example.com',
  'https://www.example.com/about' â†’ 'example.com',
  'example.com/products/item?id=123' â†’ 'example.com',
  'https://blog.example.com' â†’ 'blog.example.com', // Keep subdomains
  'EXAMPLE.COM' â†’ 'example.com', // Handle case
  '  example.com  ' â†’ 'example.com', // Handle whitespace
  'example.co.uk' â†’ 'example.co.uk', // Handle multi-part TLDs
  'example.com#section' â†’ 'example.com', // Remove fragments
  'example.com:3000' â†’ 'example.com', // Remove ports
  'https://example.com:443/page' â†’ 'example.com',
  'shop.example.com/products' â†’ 'shop.example.com',
  'example.in' â†’ 'example.in', // Handle country TLDs
  'mÃ¼nchen.de' â†’ 'mÃ¼nchen.de', // Handle international domains
];
```

### 4. ENHANCED USER EXPERIENCE

Add smart URL handling features:
```javascript
// Auto-corrections and user feedback
const smartUrlHandler = (input) => {
  const corrections = {
    'gooogle.com': 'google.com',
    'facebok.com': 'facebook.com',
    // Add common typos
  };
  
  // Check for common mistakes
  if (input.includes(' ')) {
    showWarning('Spaces detected - cleaning URL...');
  }
  
  if (input.includes(',')) {
    // Multiple URLs? Take the first one
    input = input.split(',')[0];
  }
  
  // Visual indicator of what we're processing
  return {
    original: input,
    processed: extractCleanDomain(input),
    confidence: calculateUrlConfidence(input)
  };
};
```

### 5. VALIDATION LAYER

Add robust validation:
```javascript
const validateDomain = (domain) => {
  // Check if domain has valid TLD
  const validTLDs = ['com', 'org', 'net', 'io', 'co', 'in', 'uk', 'de', 'fr', /* ... */];
  const tld = domain.split('.').pop();
  
  if (!validTLDs.includes(tld) && tld.length < 2) {
    return { valid: false, reason: 'Invalid domain extension' };
  }
  
  // Check domain format
  const domainRegex = /^([a-z0-9-]+\.)+[a-z]{2,}$/i;
  if (!domainRegex.test(domain)) {
    return { valid: false, reason: 'Invalid domain format' };
  }
  
  // Check minimum length
  if (domain.length < 4) { // x.co is minimum
    return { valid: false, reason: 'Domain too short' };
  }
  
  return { valid: true };
};
```

### 6. UI FEEDBACK INTEGRATION

Show users exactly what's being analyzed:
```javascript
// In your search component
<div className="search-container">
  <input
    type="text"
    placeholder="Enter your website URL (e.g., example.com)"
    value={inputValue}
    onChange={(e) => setInputValue(e.target.value)}
    onBlur={() => {
      if (inputValue) {
        const clean = extractCleanDomain(inputValue);
        setDisplayValue(`Analyzing: ${clean}`);
      }
    }}
  />
  {displayValue && (
    <span className="processed-url-indicator">
      âœ“ {displayValue}
    </span>
  )}
</div>
```

### 7. ERROR HANDLING EXCELLENCE
```javascript
const urlErrors = {
  NO_TLD: "Please include a domain extension (.com, .org, etc.)",
  INVALID_CHARS: "URL contains invalid characters",
  TOO_SHORT: "Please enter a complete domain name",
  MALFORMED: "Unable to parse URL. Try format: example.com",
  LOCALHOST: "Cannot analyze localhost. Please use a public domain",
  IP_ADDRESS: "Please use a domain name instead of IP address",
  PRIVATE: "This appears to be a private/internal domain"
};

// Smart error detection
const getUrlError = (input) => {
  if (input.includes('localhost')) return urlErrors.LOCALHOST;
  if (/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/.test(input)) return urlErrors.IP_ADDRESS;
  if (!input.includes('.')) return urlErrors.NO_TLD;
  if (input.length < 4) return urlErrors.TOO_SHORT;
  // ... more checks
};
```

### 8. PERFORMANCE OPTIMIZATION
```javascript
// Cache processed domains to avoid re-parsing
const domainCache = new Map();

export const getCachedDomain = (input) => {
  if (domainCache.has(input)) {
    return domainCache.get(input);
  }
  
  const domain = extractCleanDomain(input);
  domainCache.set(input, domain);
  
  // Limit cache size
  if (domainCache.size > 100) {
    const firstKey = domainCache.keys().next().value;
    domainCache.delete(firstKey);
  }
  
  return domain;
};
```

## CRITICAL SUCCESS FACTORS

âœ… ALWAYS extract just the domain + TLD (example.com, not example.com/page)
âœ… PRESERVE subdomains when present (blog.example.com stays as blog.example.com)
âœ… HANDLE all common URL formats users might input
âœ… PROVIDE clear feedback about what's being analyzed
âœ… NEVER send paths, parameters, or fragments to the analysis API
âœ… GRACEFULLY handle edge cases and malformed inputs

## IMPLEMENTATION NOTES

1. This parser is the GATEWAY to your analysis - it must be bulletproof
2. Users will paste URLs from everywhere - be ready for anything
3. The cleaner the domain, the better your analysis results
4. Fast feedback is crucial - show users immediately what domain you extracted
5. When in doubt, be liberal in what you accept but strict in what you process

## FINAL INTEGRATION

Connect this to your existing search bar in the hero section. When the user clicks "Get Instant Results", the URL should be parsed, cleaned, and only the domain should be sent to your analysis backend.

Remember: Users don't think about URL structure. They just want to paste their website and get results. Make it magical. ðŸŽ¯

The domain parser should feel invisible but be unbreakable. Ship it! ðŸš€
This prompt provides a comprehensive, production-ready URL parsing implementation that will ensure only clean domains are sent to your analysis backend, handling every edge case users might throw at it.